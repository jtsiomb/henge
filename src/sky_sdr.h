#ifndef SKY_CC_IMPL
#error "don't include sky_sdr.h!"
#endif
// default procedural cloud shaders, can be overriden if needed

static const char *def_clouds_vs =
	"void main()\n"
	"{\n"
	"\tgl_Position = ftransform();\n"
	"\tgl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;\n"
	"\tgl_FrontColor = gl_Color;\n"
	"}\n";

static const char *def_clouds_ps =
	"uniform sampler2D perm_texture;\n"
	"uniform float cloud_cover, cloud_sharpness;\n"
	"uniform float pixw, halfpixw;\n"
	"\n"
	"float cloud_curve(float v, float cover, float sharpness);\n"
	"float pnoise(vec3 p);\n"
	"float fractal_noise(vec3 p);\n"
	"\n"
	"void main()\n"
	"{\n"
	"	vec3 tc = gl_TexCoord[0].xyz * vec3(16.0, 16.0, 1.0);\n"
	"	float pn = fractal_noise(tc) * 0.5 + 0.5;\n"
	"	float cloud = cloud_curve(pn, cloud_cover, cloud_sharpness);\n"
	"\n"
	"	vec4 col = gl_Color;\n"
	"	col.w *= cloud;\n"
	"\n"
	"	gl_FragColor = col;\n"
	"}\n"
	"\n"
	"float cloud_curve(float v, float cover, float sharpness)\n"
	"{\n"
	"	float c = max(cover - v, 0.0);\n"
	"	return 1.0 - pow(1.0 - sharpness, c);\n"
	"}\n"
	"\n"
	"float fractal_noise(vec3 p)\n"
	"{\n"
	"	return pnoise(p) +\n"
	"		pnoise(p * 2.0) / 2.0 +\n"
	"		pnoise(p * 4.0) / 4.0 +\n"
	"		pnoise(p * 8.0) / 8.0 +\n"
	"		pnoise(p * 16.0) / 16.0;\n"
	"}\n"
	"\n"
	"\n"
	"float fade(float t)\n"
	"{\n"
	"	return t * t * (3.0 - 2.0 * t);\n"
	"	/* return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); */\n"
	"}\n"
	"\n"
	"\n"
	"float pnoise(vec3 p)\n"
	"{\n"
	"	vec3 pi = pixw * floor(p) + halfpixw; /* Integer part, scaled so +1 moves one texel */\n"
	"										/* and offset 1/2 texel to sample texel centers */\n"
	"	vec3 pf = fract(p);		/* Fractional part for interpolation */\n"
	"\n"
	"	/* Noise contributions from (x=0, y=0), z=0 and z=1 */\n"
	"	float perm00 = texture2D(perm_texture, pi.xy).a ;\n"
	"	vec3 grad000 = texture2D(perm_texture, vec2(perm00, pi.z)).rgb * 4.0 - 1.0;\n"
	"	float n000 = dot(grad000, pf);\n"
	"	vec3 grad001 = texture2D(perm_texture, vec2(perm00, pi.z + pixw)).rgb * 4.0 - 1.0;\n"
	"	float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));\n"
	"\n"
	"	/* Noise contributions from (x=0, y=1), z=0 and z=1 */\n"
	"	float perm01 = texture2D(perm_texture, pi.xy + vec2(0.0, pixw)).a ;\n"
	"	vec3 grad010 = texture2D(perm_texture, vec2(perm01, pi.z)).rgb * 4.0 - 1.0;\n"
	"	float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));\n"
	"	vec3 grad011 = texture2D(perm_texture, vec2(perm01, pi.z + pixw)).rgb * 4.0 - 1.0;\n"
	"	float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));\n"
	"\n"
	"	/* Noise contributions from (x=1, y=0), z=0 and z=1 */\n"
	"	float perm10 = texture2D(perm_texture, pi.xy + vec2(pixw, 0.0)).a ;\n"
	"	vec3 grad100 = texture2D(perm_texture, vec2(perm10, pi.z)).rgb * 4.0 - 1.0;\n"
	"	float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));\n"
	"	vec3 grad101 = texture2D(perm_texture, vec2(perm10, pi.z + pixw)).rgb * 4.0 - 1.0;\n"
	"	float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));\n"
	"\n"
	"	/* Noise contributions from (x=1, y=1), z=0 and z=1 */\n"
	"	float perm11 = texture2D(perm_texture, pi.xy + vec2(pixw, pixw)).a ;\n"
	"	vec3 grad110 = texture2D(perm_texture, vec2(perm11, pi.z)).rgb * 4.0 - 1.0;\n"
	"	float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));\n"
	"	vec3 grad111 = texture2D(perm_texture, vec2(perm11, pi.z + pixw)).rgb * 4.0 - 1.0;\n"
	"	float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));\n"
	"\n"
	"	/* Blend contributions along x */\n"
	"	vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));\n"
	"\n"
	"	/* Blend contributions along y */\n"
	"	vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));\n"
	"\n"
	"	/* Blend contributions along z */\n"
	"	float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));\n"
	"\n"
	"	/* We're done, return the final noise value. */\n"
	"	return n_xyz;\n"
	"}\n";
