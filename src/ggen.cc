// This is beautiful, essentially every primitive is generated by a single function!
#include <vector>
#include "ggen.h"

using namespace henge;

static void geosphere(std::vector<Vector3> *verts, const Vector3 &v1, const Vector3 &v2, const Vector3 &v3, int iter);

static bool generic_heightfield(trimesh *mesh, int usub, int vsub,
		float umax, float vmax,	gen_sample_func dist_func, void *dist_func_cls,
		Vector3 (*vertex)(float, float, float), tex_coord_gen tcgen);

static Vector3 vertex_revol(float u, float v, float dist);
static Vector3 vertex_plane(float u, float v, float dist);

static Vector2 tex_xz(float u, float v, const Vector3 &vert);
static Vector2 tex_xy(float u, float v, const Vector3 &vert);
static Vector2 tex_uv(float u, float v, const Vector3 &vert);


// this array must remain in sync with the tex_coord_gen enumeration in ggen.h

static Vector2 (*tex_func[])(float, float, const Vector3&) = {
	tex_xz,
	tex_xy,
	tex_uv
};

/* gen_revol (surface of revolution) is a special case of a heightfield, defined
 * by the distance around the Y axis.
 */
bool henge::gen_revol(trimesh *mesh, int usub, int vsub, float umax, float vmax,
		gen_sample_func dist_func, void *dist_func_cls, tex_coord_gen tcgen)
{
	return generic_heightfield(mesh, usub, vsub, umax, vmax, dist_func, dist_func_cls,
			vertex_revol, tcgen);
}

/* gen_height (heighfield) is also defined in terms of the generic_heightfield
 * function
 */
bool henge::gen_height(trimesh *mesh, int usub, int vsub, gen_sample_func height_func,
		void *height_func_cls, tex_coord_gen tcgen)
{
	return generic_heightfield(mesh, usub, vsub, 1, 1, height_func, height_func_cls,
			vertex_plane, tcgen);
}

/* Surface of revolution distance evaluator for a sphere.
 * The closure pointer points to the radius of the cylinder.
 */
static float sph_dist_func(float u, float v, void *cls)
{
	return fabs(sin(v * PI));
}

// special case because we want the sphere to have radius, not diameter of 1
static Vector3 vertex_revol_sph(float u, float v, float dist)
{
	return Vector3(sin(u * TWO_PI) * dist, 2.0 * (v - 0.5), cos(u * TWO_PI) * dist).normalized();
}

// a sphere is a surface of revolution ... 
bool henge::gen_sphere(trimesh *mesh, float rad, int slices, int stacks, float umax,
		float vmax, tex_coord_gen tcgen)
{
	if(!generic_heightfield(mesh, slices, stacks, umax, vmax, sph_dist_func, &rad,
			vertex_revol_sph, tcgen)) {
		return false;
	}

	Vector3 *vert = mesh->get_data_vec3(EL_VERTEX);
	Vector3 *norm = mesh->get_data_vec3(EL_NORMAL);
	for(int i=0; i<mesh->get_count(EL_VERTEX); i++) {
		norm[i] = vert[i].normalized();	// recalc normals to avoid singularity at the poles
		vert[i] *= rad;	// this is where we make the sphere the proper size
	}
	return true;
}

/* Surface of revolution distance evaluator for a cylinder.
 * The closure pointer points to the radius of the cylinder.
 */
static float cyl_dist_func(float u, float v, void *cls)
{
	return 0.5f * *(float*)cls;
}

// a cylinder is a surface of revolution ...
bool henge::gen_cylinder(trimesh *mesh, float rad, int slices, int stacks, float umax,
		tex_coord_gen tcgen)
{
	return gen_revol(mesh, slices, stacks, umax, 1, cyl_dist_func, &rad, tcgen);
}


static float plane_dist_func(float u, float v, void *cls)
{
	return 0.0f;
}

// a plane is a heightfield with a constant height of 0
bool henge::gen_plane(trimesh *mesh, int usub, int vsub, tex_coord_gen tcgen)
{
	return gen_height(mesh, usub, vsub, plane_dist_func, 0, tcgen);
}

/*
static Vector3 box_pt[] = {
	// front
	Vector3(-1, -1, 1), Vector3(1, -1, 1), Vector3(1, 1, 1), Vector3(-1, 1, 1),
	// right
	Vector3(1, -1, 1), Vector3(1, -1, -1), Vector3(1, 1, -1), Vector3(1, 1, 1),
	// back
	Vector3(1, -1, -1), Vector3(-1, -1, -1), Vector3(-1, 1, -1), Vector3(1, 1, -1),
	// left
	Vector3(-1, -1, -1), Vector3(-1, -1, 1), Vector3(-1, 1, 1), Vector3(-1, 1, -1),
	// top
	Vector3(-1, 1, 1), Vector3(1, 1, 1), Vector3(1, 1, -1), Vector3(-1, 1, -1),
	// bottom
	Vector3(1, -1, -1), Vector3(-1, -1, -1), Vector3(-1, -1, 1), Vector3(1, -1, 1)
};

#define X4(x)	x, x, x, x
#define X6(x)	x, x, x, x, x, x

static Vector3 box_norm[] = {
	X4(Vector3(0, 0, 1)),
	X4(Vector3(1, 0, 0)),
	X4(Vector3(0, 0, -1)),
	X4(Vector3(-1, 0, 0)),
	X4(Vector3(0, 1, 0)),
	X4(Vector3(0, -1, 0))
};

static Vector3 box_tang[] = {
	X4(Vector3(1, 0, 0)),
	X4(Vector3(0, 0, -1)),
	X4(Vector3(-1, 0, 0)),
	X4(Vector3(0, 0, 1)),
	X4(Vector3(1, 0, 0)),
	X4(Vector3(-1, 0, 0))
};

static Vector2 box_tc[] = {
	X6(Vector2(0, 0), Vector2(1, 0), Vector2(1, 1), Vector2(0, 1))
};
*/

// TODO take tcgen into account
bool henge::gen_box(trimesh *mesh, float xsz, float ysz, float zsz, int xsub, int ysub, int zsub, tex_coord_gen tcgen)
{

	// front
	{
		Matrix4x4 mat;
		trimesh face;
		gen_plane(&face, xsub, ysub);
		mat.rotate(Vector3(HALF_PI, 0, 0));
		mat.translate(Vector3(0, zsz, 0));
		mat.scale(Vector3(xsz, 1, ysz));
		face.transform(mat);
		*mesh = face;
	}

	// right
	{
		Matrix4x4 mat;
		trimesh face;
		gen_plane(&face, zsub, ysub);
		mat.rotate(Vector3(0, HALF_PI, 0));
		mat.rotate(Vector3(HALF_PI, 0, 0));
		mat.translate(Vector3(0, xsz, 0));
		mat.scale(Vector3(zsz, 1, ysz));
		face.transform(mat);
		mesh->merge(face);
	}

	// back
	{
		Matrix4x4 mat;
		trimesh face;
		gen_plane(&face, xsub, ysub);
		mat.rotate(Vector3(0, PI, 0));
		mat.rotate(Vector3(HALF_PI, 0, 0));
		mat.translate(Vector3(0, zsz, 0));
		mat.scale(Vector3(xsz, 1, ysz));
		face.transform(mat);
		mesh->merge(face);
	}

	// left
	{
		Matrix4x4 mat;
		trimesh face;
		gen_plane(&face, zsub, ysub);
		mat.rotate(Vector3(0, -HALF_PI, 0));
		mat.rotate(Vector3(HALF_PI, 0, 0));
		mat.translate(Vector3(0, xsz, 0));
		mat.scale(Vector3(zsz, 1, ysz));
		face.transform(mat);
		mesh->merge(face);
	}

	// top
	{
		Matrix4x4 mat;
		trimesh face;
		gen_plane(&face, xsub, zsub);
		mat.translate(Vector3(0, ysz, 0));
		mat.scale(Vector3(xsz, 1, zsz));
		face.transform(mat);
		mesh->merge(face);
	}

	// bottom
	{
		Matrix4x4 mat;
		trimesh face;
		gen_plane(&face, xsub, zsub);
		mat.rotate(Vector3(PI, 0, 0));
		mat.translate(Vector3(0, ysz, 0));
		mat.scale(Vector3(xsz, 1, zsz));
		face.transform(mat);
		mesh->merge(face);
	}

	return true;
}


#define PHI		1.618034

static Vector3 icosa_pt[] = {
	Vector3(PHI, 1, 0),
	Vector3(-PHI, 1, 0),
	Vector3(PHI, -1, 0),
	Vector3(-PHI, -1, 0),
	Vector3(1, 0, PHI),
	Vector3(1, 0, -PHI),
	Vector3(-1, 0, PHI),
	Vector3(-1, 0, -PHI),
	Vector3(0, PHI, 1),
	Vector3(0, -PHI, 1),
	Vector3(0, PHI, -1),
	Vector3(0, -PHI, -1)
};
enum { P11, P12, P13, P14, P21, P22, P23, P24, P31, P32, P33, P34 };
static int icosa_idx[] = {
	P11, P31, P21,
	P11, P22, P33,
	P13, P21, P32,
	P13, P34, P22,
	P12, P23, P31,
	P12, P33, P24,
	P14, P32, P23,
	P14, P24, P34,

	P11, P33, P31,
	P12, P31, P33,
	P13, P32, P34,
	P14, P34, P32,

	P21, P13, P11,
	P22, P11, P13,
	P23, P12, P14,
	P24, P14, P12,

	P31, P23, P21,
	P32, P21, P23,
	P33, P22, P24,
	P34, P24, P22
};

bool henge::gen_icosa(trimesh *mesh, tex_coord_gen tcgen)
{
	int num_idx = sizeof icosa_idx / sizeof *icosa_idx;
	int num_tri = num_idx / 3;
	int num_vert = num_idx;

	mesh->set_data(EL_VERTEX, (Vector3*)0, num_vert);
	mesh->set_data(EL_NORMAL, (Vector3*)0, num_vert);

	Vector3 *vert = mesh->get_data_vec3(EL_VERTEX);
	Vector3 *norm = mesh->get_data_vec3(EL_NORMAL);

	for(int i=0; i<num_tri; i++) {
		int vidx0 = icosa_idx[i * 3];
		int vidx1 = icosa_idx[i * 3 + 1];
		int vidx2 = icosa_idx[i * 3 + 2];

		// position
		vert[0] = icosa_pt[vidx0];
		vert[1] = icosa_pt[vidx1];
		vert[2] = icosa_pt[vidx2];

		// normal
		Vector3 v1 = vert[1] - vert[0];
		Vector3 v2 = vert[2] - vert[0];
		Vector3 n = cross_product(v1, v2).normalized();

		norm[0] = norm[1] = norm[2] = n;

		vert += 3;
		norm += 3;
	}

	return true;
}

bool henge::gen_geosphere(trimesh *mesh, float rad, int subdiv, bool hemi, tex_coord_gen tcgen)
{
	int num_tri = (sizeof icosa_idx / sizeof *icosa_idx) / 3;

	std::vector<Vector3> verts;
	for(int i=0; i<num_tri; i++) {
		int vidx0 = icosa_idx[i * 3];
		int vidx1 = icosa_idx[i * 3 + 1];
		int vidx2 = icosa_idx[i * 3 + 2];

		Vector3 v1 = icosa_pt[vidx0].normalized();
		Vector3 v2 = icosa_pt[vidx1].normalized();
		Vector3 v3 = icosa_pt[vidx2].normalized();

		if(hemi && (v1.y < 0.0 || v2.y < 0.0 || v3.y < 0.0)) {
			continue;
		}

		geosphere(&verts, v1, v2, v3, subdiv);
	}

	mesh->set_data(EL_VERTEX, &verts[0], verts.size());
	mesh->set_data(EL_NORMAL, &verts[0], verts.size());

	Vector3 *varr = mesh->get_data_vec3(EL_VERTEX);

	for(size_t i=0; i<verts.size(); i++) {
		varr[i] *= rad;
	}
	return true;
}

static void geosphere(std::vector<Vector3> *verts, const Vector3 &v1, const Vector3 &v2,
		const Vector3 &v3, int iter)
{
	if(!iter) {
		verts->push_back(v1);
		verts->push_back(v2);
		verts->push_back(v3);
		return;
	}

	Vector3 v12 = (v1 + v2).normalized();
	Vector3 v23 = (v2 + v3).normalized();
	Vector3 v31 = (v3 + v1).normalized();

	geosphere(verts, v1, v12, v31, iter - 1);
	geosphere(verts, v2, v23, v12, iter - 1);
	geosphere(verts, v3, v31, v23, iter - 1);
	geosphere(verts, v12, v23, v31, iter - 1);
}

bool gen_dodeca(trimesh *mesh, tex_coord_gen tcgen)
{
	return false;
}


/* The following static functions are either helpers (see tex_* tang_*) or
 * common code of the gen_* functions above that has been factored out
 * (see generic_heightfield).
 */

#define QUAD(a, b, c, d)	\
	do {	\
		*iptr++ = a;	\
		*iptr++ = b;	\
		*iptr++ = c;	\
		*iptr++ = a;	\
		*iptr++ = c;	\
		*iptr++ = d;	\
	} while(0)

static Vector3 vertex_revol(float u, float v, float dist)
{
	return Vector3(sin(u * TWO_PI) * dist, v - 0.5, cos(u * TWO_PI) * dist);
}

static Vector3 vertex_plane(float u, float v, float dist)
{
	return Vector3(2.0 * u - 1.0, dist, 2.0 * (0.5 - v));
}

/* right... this function can generate both heightfields on a plane, and around
 * an axis (surface of revolution), by just supplying the correct vertex(u, v, dist)
 * function (see above). So it's the common base for both gen_revol and gen_height.
 */
static bool generic_heightfield(trimesh *mesh, int usub, int vsub,
		float umax, float vmax,	gen_sample_func dist_func, void *dist_func_cls,
		Vector3 (*vertex)(float, float, float), tex_coord_gen tcgen)
{
	if(!mesh || !dist_func) {
		return false;
	}

	int unum = usub + 1;
	int vnum = vsub + 1;
	int num_verts = unum * vnum;
	int num_quads = usub * vsub;
	int num_tris = num_quads * 2;
	int num_idx = num_tris * 3;

	// allocate mesh data storage
	if(!mesh->set_data(EL_VERTEX, (Vector3*)0, num_verts) ||
			!mesh->set_data(EL_NORMAL, (Vector3*)0, num_verts) ||
			!mesh->set_data(EL_TANGENT, (Vector3*)0, num_verts) ||
			!mesh->set_data(EL_TEXCOORD, (Vector2*)0, num_verts) ||
			!mesh->set_data(EL_INDEX, (unsigned int*)0, num_idx)) {
		return false;
	}

	// retrieve pointers to the allocated arrays
	Vector3 *vptr = mesh->get_data_vec3(EL_VERTEX);
	Vector3 *nptr = mesh->get_data_vec3(EL_NORMAL);
	Vector3 *tptr = mesh->get_data_vec3(EL_TANGENT);
	Vector2 *xptr = mesh->get_data_vec2(EL_TEXCOORD);
	unsigned int *iptr = mesh->get_data_int(EL_INDEX);

	// generate vertices
	for(int i=0; i<unum; i++) {
		float u = umax * (float)i / (float)usub;

		for(int j=0; j<vnum; j++) {
			float v = vmax * (float)j / (float)vsub;

			float dist = dist_func(u, v, dist_func_cls);
			Vector3 vert = vertex(u, v, dist);

			Vector3 uprev = vertex(u - 0.01, v, dist_func(u - 0.01, v, dist_func_cls));
			Vector3 unext = vertex(u + 0.01, v, dist_func(u + 0.01, v, dist_func_cls));
			Vector3 tang = unext - uprev;

			Vector3 vprev = vertex(u, v - 0.01, dist_func(u, v - 0.01, dist_func_cls));
			Vector3 vnext = vertex(u, v + 0.01, dist_func(u, v + 0.01, dist_func_cls));
			Vector3 bitan = vnext - vprev;

			Vector3 norm = cross_product(tang, bitan).normalized();

			*vptr++ = vert;
			*nptr++ = norm;
			*tptr++ = tang.normalized();
			*xptr++ = tex_func[tcgen](u, v, vert);
		}
	}

	// construct indices
	for(int i=0; i<usub; i++) {
		int base = i * vnum;
		for(int j=0; j<vsub; j++) {
			QUAD(j + base,
				vnum + j + base,
				vnum + 1 + j + base,
				1 + j + base);
		}
	}

	return true;
}

static Vector2 tex_xz(float u, float v, const Vector3 &vert)
{
	return Vector2(vert.x * 0.5 + 0.5, vert.z * 0.5 + 0.5);
}

static Vector2 tex_xy(float u, float v, const Vector3 &vert)
{
	return Vector2(vert.x * 0.5 + 0.5, vert.y * 0.5 + 0.5);
}

static Vector2 tex_uv(float u, float v, const Vector3 &vert)
{
	return Vector2(u, 1.0 - v);
}
